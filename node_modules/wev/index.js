#!/bin/sh
':' //; exec "$(command -v nodejs || command -v node)" "$0" "$@"

var runner   = require('spawnx'),
    fs       = require('fs'),
    path     = require('path'),
    keypress = require('keypress');

var child,
    command,
    callback;

var watcher;

/*
function watch(paths) {
  paths.forEach(function(path) {
    watcher.add(path)
  })

  watcher.onChange(onChange);
}
*/

function watch(paths, cb) {
  console.log('Watching', paths);
  var instances = paths.map(function(dir) {
    return fs.watch(dir, { recursive: true }, cb)
  })

  return {
    stop: function() {
      console.log('Stopping watches...');
      instances.forEach(function(watch) {
        watch.close()
      })
    }
  }
}

function launch(cmd) {
  child = runner(cmd, {
    cwd: process.cwd(),
    stderr: process.stderr,
    stdout: process.stdout
  })

  child.on('exit', function(code) {
    console.log('Child exited with code ' + code);
    child = null;

    if (callback) callback()
  });
}

function kill() {
  if (child)
    child.kill()
}

function start(cmd, paths) {
  command = cmd;
  process.on('SIGINT', exit)

  launch(cmd);
  watcher = watch(paths, onChange);

  listenKeys();
}

function listenKeys() {
  keypress(process.stdin);

  process.stdin.on('keypress', function(ch, key) {
    if (!key) return;

    if (key.name == 'r')
      onChange();

    if (key.name == 'q' || (key.ctrl && key.name == 'c'))
      exit();
  });

  process.stdin.setRawMode(true);

  process.on('exit', function() {
    console.log('Restoring stdin.');
    process.stdin.setRawMode(false);
    // process.stdin.resume();
  })
}

function onChange(evt) {
  console.log('Change detected: ', evt)

  if (!child)
    return launch(command)

  callback = function restart() {
    console.log('Restarting...')
    callback = null;
    launch(command);
  }

  kill()
}

function stop(cb) {
  kill()

  // watcher.clearListeners();
  watcher.stop()
  process.removeListener('SIGINT', exit)
}

function exit() {
  stop()

  callback = function() {
    console.log('Exiting...')
    process.exit(0)
  }
}

function readLine(file, line) {
  var res;
  try { res = fs.readFileSync(file, 'utf-8') } catch(e) { }

  if (!res) return; // no match
  if (!line) return res.split('\n')[0]; // first
  return (res.match(new RegExp('^' + line + '(.*)')) || [])[1]; // match
}

function getEnv() {
  try { return fs.readFileSync('/.env', 'utf8').split('\n') } catch(e) { }
}

function getCommand() {
  var cmd = readLine('./Procfile', 'web:')
  if (!cmd) cmd = readLine('./Procfile', 'app:')
  if (!cmd) return;

  if (cmd.indexOf('$PORT') == -1)
    return cmd.trim();

  var port = readLine('.env', 'PORT=');
  return cmd.replace('$PORT', port).trim();
}

exports.start = start;
exports.stop  = stop;

if (require.main === module) {
  var cmd = getCommand();
  var dirs = process.argv.length > 2 ? process.argv.slice(2) : ['lib'];
  if (cmd) start(cmd, dirs);
}
